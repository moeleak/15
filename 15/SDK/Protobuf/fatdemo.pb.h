// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fatdemo.proto

#ifndef PROTOBUF_fatdemo_2eproto__INCLUDED
#define PROTOBUF_fatdemo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "netmessages.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_fatdemo_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsMLDictImpl();
void InitDefaultsMLDict();
void InitDefaultsMLEventImpl();
void InitDefaultsMLEvent();
void InitDefaultsMLMatchStateImpl();
void InitDefaultsMLMatchState();
void InitDefaultsMLRoundStateImpl();
void InitDefaultsMLRoundState();
void InitDefaultsMLWeaponStateImpl();
void InitDefaultsMLWeaponState();
void InitDefaultsMLPlayerStateImpl();
void InitDefaultsMLPlayerState();
void InitDefaultsMLGameStateImpl();
void InitDefaultsMLGameState();
void InitDefaultsMLDemoHeaderImpl();
void InitDefaultsMLDemoHeader();
void InitDefaultsMLTickImpl();
void InitDefaultsMLTick();
inline void InitDefaults() {
  InitDefaultsMLDict();
  InitDefaultsMLEvent();
  InitDefaultsMLMatchState();
  InitDefaultsMLRoundState();
  InitDefaultsMLWeaponState();
  InitDefaultsMLPlayerState();
  InitDefaultsMLGameState();
  InitDefaultsMLDemoHeader();
  InitDefaultsMLTick();
}
}  // namespace protobuf_fatdemo_2eproto
class MLDemoHeader;
class MLDemoHeaderDefaultTypeInternal;
extern MLDemoHeaderDefaultTypeInternal _MLDemoHeader_default_instance_;
class MLDict;
class MLDictDefaultTypeInternal;
extern MLDictDefaultTypeInternal _MLDict_default_instance_;
class MLEvent;
class MLEventDefaultTypeInternal;
extern MLEventDefaultTypeInternal _MLEvent_default_instance_;
class MLGameState;
class MLGameStateDefaultTypeInternal;
extern MLGameStateDefaultTypeInternal _MLGameState_default_instance_;
class MLMatchState;
class MLMatchStateDefaultTypeInternal;
extern MLMatchStateDefaultTypeInternal _MLMatchState_default_instance_;
class MLPlayerState;
class MLPlayerStateDefaultTypeInternal;
extern MLPlayerStateDefaultTypeInternal _MLPlayerState_default_instance_;
class MLRoundState;
class MLRoundStateDefaultTypeInternal;
extern MLRoundStateDefaultTypeInternal _MLRoundState_default_instance_;
class MLTick;
class MLTickDefaultTypeInternal;
extern MLTickDefaultTypeInternal _MLTick_default_instance_;
class MLWeaponState;
class MLWeaponStateDefaultTypeInternal;
extern MLWeaponStateDefaultTypeInternal _MLWeaponState_default_instance_;

enum EHitGroup {
  EHG_Generic = 0,
  EHG_Head = 1,
  EHG_Chest = 2,
  EHG_Stomach = 3,
  EHG_LeftArm = 4,
  EHG_RightArm = 5,
  EHG_LeftLeg = 6,
  EHG_RightLeg = 7,
  EHG_Gear = 8,
  EHG_Miss = 9
};
bool EHitGroup_IsValid(int value);
const EHitGroup EHitGroup_MIN = EHG_Generic;
const EHitGroup EHitGroup_MAX = EHG_Miss;
const int EHitGroup_ARRAYSIZE = EHitGroup_MAX + 1;

const ::google::protobuf::EnumDescriptor* EHitGroup_descriptor();
inline const ::std::string& EHitGroup_Name(EHitGroup value) {
  return ::google::protobuf::internal::NameOfEnum(
    EHitGroup_descriptor(), value);
}
inline bool EHitGroup_Parse(
    const ::std::string& name, EHitGroup* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EHitGroup>(
    EHitGroup_descriptor(), name, value);
}
enum ETeam {
  ET_Unknown = 0,
  ET_Spectator = 1,
  ET_Terrorist = 2,
  ET_CT = 3
};
bool ETeam_IsValid(int value);
const ETeam ETeam_MIN = ET_Unknown;
const ETeam ETeam_MAX = ET_CT;
const int ETeam_ARRAYSIZE = ETeam_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETeam_descriptor();
inline const ::std::string& ETeam_Name(ETeam value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETeam_descriptor(), value);
}
inline bool ETeam_Parse(
    const ::std::string& name, ETeam* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETeam>(
    ETeam_descriptor(), name, value);
}
enum EWeaponType {
  EWT_Knife = 0,
  EWT_Pistol = 1,
  EWT_SubMachineGun = 2,
  EWT_Rifle = 3,
  EWT_Shotgun = 4,
  EWT_SniperRifle = 5,
  EWT_MachineGun = 6,
  EWT_C4 = 7,
  EWT_Grenade = 8,
  EWT_Equipment = 9,
  EWT_StackableItem = 10,
  EWT_Unknown = 11
};
bool EWeaponType_IsValid(int value);
const EWeaponType EWeaponType_MIN = EWT_Knife;
const EWeaponType EWeaponType_MAX = EWT_Unknown;
const int EWeaponType_ARRAYSIZE = EWeaponType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EWeaponType_descriptor();
inline const ::std::string& EWeaponType_Name(EWeaponType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EWeaponType_descriptor(), value);
}
inline bool EWeaponType_Parse(
    const ::std::string& name, EWeaponType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EWeaponType>(
    EWeaponType_descriptor(), name, value);
}
// ===================================================================

class MLDict : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLDict) */ {
 public:
  MLDict();
  virtual ~MLDict();

  MLDict(const MLDict& from);

  inline MLDict& operator=(const MLDict& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MLDict(MLDict&& from) noexcept
    : MLDict() {
    *this = ::std::move(from);
  }

  inline MLDict& operator=(MLDict&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLDict& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLDict* internal_default_instance() {
    return reinterpret_cast<const MLDict*>(
               &_MLDict_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MLDict* other);
  friend void swap(MLDict& a, MLDict& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MLDict* New() const PROTOBUF_FINAL { return New(NULL); }

  MLDict* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MLDict& from);
  void MergeFrom(const MLDict& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MLDict* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string val_string = 2;
  bool has_val_string() const;
  void clear_val_string();
  static const int kValStringFieldNumber = 2;
  const ::std::string& val_string() const;
  void set_val_string(const ::std::string& value);
  #if LANG_CXX11
  void set_val_string(::std::string&& value);
  #endif
  void set_val_string(const char* value);
  void set_val_string(const char* value, size_t size);
  ::std::string* mutable_val_string();
  ::std::string* release_val_string();
  void set_allocated_val_string(::std::string* val_string);

  // optional int32 val_int = 3;
  bool has_val_int() const;
  void clear_val_int();
  static const int kValIntFieldNumber = 3;
  ::google::protobuf::int32 val_int() const;
  void set_val_int(::google::protobuf::int32 value);

  // optional float val_float = 4;
  bool has_val_float() const;
  void clear_val_float();
  static const int kValFloatFieldNumber = 4;
  float val_float() const;
  void set_val_float(float value);

  // @@protoc_insertion_point(class_scope:MLDict)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_val_string();
  void clear_has_val_string();
  void set_has_val_int();
  void clear_has_val_int();
  void set_has_val_float();
  void clear_has_val_float();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr val_string_;
  ::google::protobuf::int32 val_int_;
  float val_float_;
  friend struct ::protobuf_fatdemo_2eproto::TableStruct;
  friend void ::protobuf_fatdemo_2eproto::InitDefaultsMLDictImpl();
};
// -------------------------------------------------------------------

class MLEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLEvent) */ {
 public:
  MLEvent();
  virtual ~MLEvent();

  MLEvent(const MLEvent& from);

  inline MLEvent& operator=(const MLEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MLEvent(MLEvent&& from) noexcept
    : MLEvent() {
    *this = ::std::move(from);
  }

  inline MLEvent& operator=(MLEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLEvent* internal_default_instance() {
    return reinterpret_cast<const MLEvent*>(
               &_MLEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MLEvent* other);
  friend void swap(MLEvent& a, MLEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MLEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  MLEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MLEvent& from);
  void MergeFrom(const MLEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MLEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MLDict data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::MLDict& data(int index) const;
  ::MLDict* mutable_data(int index);
  ::MLDict* add_data();
  ::google::protobuf::RepeatedPtrField< ::MLDict >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::MLDict >&
      data() const;

  // optional string event_name = 1;
  bool has_event_name() const;
  void clear_event_name();
  static const int kEventNameFieldNumber = 1;
  const ::std::string& event_name() const;
  void set_event_name(const ::std::string& value);
  #if LANG_CXX11
  void set_event_name(::std::string&& value);
  #endif
  void set_event_name(const char* value);
  void set_event_name(const char* value, size_t size);
  ::std::string* mutable_event_name();
  ::std::string* release_event_name();
  void set_allocated_event_name(::std::string* event_name);

  // @@protoc_insertion_point(class_scope:MLEvent)
 private:
  void set_has_event_name();
  void clear_has_event_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MLDict > data_;
  ::google::protobuf::internal::ArenaStringPtr event_name_;
  friend struct ::protobuf_fatdemo_2eproto::TableStruct;
  friend void ::protobuf_fatdemo_2eproto::InitDefaultsMLEventImpl();
};
// -------------------------------------------------------------------

class MLMatchState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLMatchState) */ {
 public:
  MLMatchState();
  virtual ~MLMatchState();

  MLMatchState(const MLMatchState& from);

  inline MLMatchState& operator=(const MLMatchState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MLMatchState(MLMatchState&& from) noexcept
    : MLMatchState() {
    *this = ::std::move(from);
  }

  inline MLMatchState& operator=(MLMatchState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLMatchState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLMatchState* internal_default_instance() {
    return reinterpret_cast<const MLMatchState*>(
               &_MLMatchState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(MLMatchState* other);
  friend void swap(MLMatchState& a, MLMatchState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MLMatchState* New() const PROTOBUF_FINAL { return New(NULL); }

  MLMatchState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MLMatchState& from);
  void MergeFrom(const MLMatchState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MLMatchState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string game_mode = 1;
  bool has_game_mode() const;
  void clear_game_mode();
  static const int kGameModeFieldNumber = 1;
  const ::std::string& game_mode() const;
  void set_game_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_game_mode(::std::string&& value);
  #endif
  void set_game_mode(const char* value);
  void set_game_mode(const char* value, size_t size);
  ::std::string* mutable_game_mode();
  ::std::string* release_game_mode();
  void set_allocated_game_mode(::std::string* game_mode);

  // optional string phase = 2;
  bool has_phase() const;
  void clear_phase();
  static const int kPhaseFieldNumber = 2;
  const ::std::string& phase() const;
  void set_phase(const ::std::string& value);
  #if LANG_CXX11
  void set_phase(::std::string&& value);
  #endif
  void set_phase(const char* value);
  void set_phase(const char* value, size_t size);
  ::std::string* mutable_phase();
  ::std::string* release_phase();
  void set_allocated_phase(::std::string* phase);

  // optional int32 round = 3;
  bool has_round() const;
  void clear_round();
  static const int kRoundFieldNumber = 3;
  ::google::protobuf::int32 round() const;
  void set_round(::google::protobuf::int32 value);

  // optional int32 score_ct = 4;
  bool has_score_ct() const;
  void clear_score_ct();
  static const int kScoreCtFieldNumber = 4;
  ::google::protobuf::int32 score_ct() const;
  void set_score_ct(::google::protobuf::int32 value);

  // optional int32 score_t = 5;
  bool has_score_t() const;
  void clear_score_t();
  static const int kScoreTFieldNumber = 5;
  ::google::protobuf::int32 score_t() const;
  void set_score_t(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MLMatchState)
 private:
  void set_has_game_mode();
  void clear_has_game_mode();
  void set_has_phase();
  void clear_has_phase();
  void set_has_round();
  void clear_has_round();
  void set_has_score_ct();
  void clear_has_score_ct();
  void set_has_score_t();
  void clear_has_score_t();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr game_mode_;
  ::google::protobuf::internal::ArenaStringPtr phase_;
  ::google::protobuf::int32 round_;
  ::google::protobuf::int32 score_ct_;
  ::google::protobuf::int32 score_t_;
  friend struct ::protobuf_fatdemo_2eproto::TableStruct;
  friend void ::protobuf_fatdemo_2eproto::InitDefaultsMLMatchStateImpl();
};
// -------------------------------------------------------------------

class MLRoundState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLRoundState) */ {
 public:
  MLRoundState();
  virtual ~MLRoundState();

  MLRoundState(const MLRoundState& from);

  inline MLRoundState& operator=(const MLRoundState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MLRoundState(MLRoundState&& from) noexcept
    : MLRoundState() {
    *this = ::std::move(from);
  }

  inline MLRoundState& operator=(MLRoundState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLRoundState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLRoundState* internal_default_instance() {
    return reinterpret_cast<const MLRoundState*>(
               &_MLRoundState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MLRoundState* other);
  friend void swap(MLRoundState& a, MLRoundState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MLRoundState* New() const PROTOBUF_FINAL { return New(NULL); }

  MLRoundState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MLRoundState& from);
  void MergeFrom(const MLRoundState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MLRoundState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string phase = 1;
  bool has_phase() const;
  void clear_phase();
  static const int kPhaseFieldNumber = 1;
  const ::std::string& phase() const;
  void set_phase(const ::std::string& value);
  #if LANG_CXX11
  void set_phase(::std::string&& value);
  #endif
  void set_phase(const char* value);
  void set_phase(const char* value, size_t size);
  ::std::string* mutable_phase();
  ::std::string* release_phase();
  void set_allocated_phase(::std::string* phase);

  // optional string bomb_state = 3;
  bool has_bomb_state() const;
  void clear_bomb_state();
  static const int kBombStateFieldNumber = 3;
  const ::std::string& bomb_state() const;
  void set_bomb_state(const ::std::string& value);
  #if LANG_CXX11
  void set_bomb_state(::std::string&& value);
  #endif
  void set_bomb_state(const char* value);
  void set_bomb_state(const char* value, size_t size);
  ::std::string* mutable_bomb_state();
  ::std::string* release_bomb_state();
  void set_allocated_bomb_state(::std::string* bomb_state);

  // optional .ETeam win_team = 2 [default = ET_Unknown];
  bool has_win_team() const;
  void clear_win_team();
  static const int kWinTeamFieldNumber = 2;
  ::ETeam win_team() const;
  void set_win_team(::ETeam value);

  // @@protoc_insertion_point(class_scope:MLRoundState)
 private:
  void set_has_phase();
  void clear_has_phase();
  void set_has_win_team();
  void clear_has_win_team();
  void set_has_bomb_state();
  void clear_has_bomb_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr phase_;
  ::google::protobuf::internal::ArenaStringPtr bomb_state_;
  int win_team_;
  friend struct ::protobuf_fatdemo_2eproto::TableStruct;
  friend void ::protobuf_fatdemo_2eproto::InitDefaultsMLRoundStateImpl();
};
// -------------------------------------------------------------------

class MLWeaponState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLWeaponState) */ {
 public:
  MLWeaponState();
  virtual ~MLWeaponState();

  MLWeaponState(const MLWeaponState& from);

  inline MLWeaponState& operator=(const MLWeaponState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MLWeaponState(MLWeaponState&& from) noexcept
    : MLWeaponState() {
    *this = ::std::move(from);
  }

  inline MLWeaponState& operator=(MLWeaponState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLWeaponState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLWeaponState* internal_default_instance() {
    return reinterpret_cast<const MLWeaponState*>(
               &_MLWeaponState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(MLWeaponState* other);
  friend void swap(MLWeaponState& a, MLWeaponState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MLWeaponState* New() const PROTOBUF_FINAL { return New(NULL); }

  MLWeaponState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MLWeaponState& from);
  void MergeFrom(const MLWeaponState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MLWeaponState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string state = 7;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 7;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // optional int32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // optional .EWeaponType type = 3 [default = EWT_Knife];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::EWeaponType type() const;
  void set_type(::EWeaponType value);

  // optional int32 ammo_clip = 4;
  bool has_ammo_clip() const;
  void clear_ammo_clip();
  static const int kAmmoClipFieldNumber = 4;
  ::google::protobuf::int32 ammo_clip() const;
  void set_ammo_clip(::google::protobuf::int32 value);

  // optional int32 ammo_clip_max = 5;
  bool has_ammo_clip_max() const;
  void clear_ammo_clip_max();
  static const int kAmmoClipMaxFieldNumber = 5;
  ::google::protobuf::int32 ammo_clip_max() const;
  void set_ammo_clip_max(::google::protobuf::int32 value);

  // optional int32 ammo_reserve = 6;
  bool has_ammo_reserve() const;
  void clear_ammo_reserve();
  static const int kAmmoReserveFieldNumber = 6;
  ::google::protobuf::int32 ammo_reserve() const;
  void set_ammo_reserve(::google::protobuf::int32 value);

  // optional float recoil_index = 8;
  bool has_recoil_index() const;
  void clear_recoil_index();
  static const int kRecoilIndexFieldNumber = 8;
  float recoil_index() const;
  void set_recoil_index(float value);

  // @@protoc_insertion_point(class_scope:MLWeaponState)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_ammo_clip();
  void clear_has_ammo_clip();
  void set_has_ammo_clip_max();
  void clear_has_ammo_clip_max();
  void set_has_ammo_reserve();
  void clear_has_ammo_reserve();
  void set_has_state();
  void clear_has_state();
  void set_has_recoil_index();
  void clear_has_recoil_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::int32 index_;
  int type_;
  ::google::protobuf::int32 ammo_clip_;
  ::google::protobuf::int32 ammo_clip_max_;
  ::google::protobuf::int32 ammo_reserve_;
  float recoil_index_;
  friend struct ::protobuf_fatdemo_2eproto::TableStruct;
  friend void ::protobuf_fatdemo_2eproto::InitDefaultsMLWeaponStateImpl();
};
// -------------------------------------------------------------------

class MLPlayerState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLPlayerState) */ {
 public:
  MLPlayerState();
  virtual ~MLPlayerState();

  MLPlayerState(const MLPlayerState& from);

  inline MLPlayerState& operator=(const MLPlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MLPlayerState(MLPlayerState&& from) noexcept
    : MLPlayerState() {
    *this = ::std::move(from);
  }

  inline MLPlayerState& operator=(MLPlayerState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLPlayerState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLPlayerState* internal_default_instance() {
    return reinterpret_cast<const MLPlayerState*>(
               &_MLPlayerState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MLPlayerState* other);
  friend void swap(MLPlayerState& a, MLPlayerState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MLPlayerState* New() const PROTOBUF_FINAL { return New(NULL); }

  MLPlayerState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MLPlayerState& from);
  void MergeFrom(const MLPlayerState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MLPlayerState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MLWeaponState weapons = 20;
  int weapons_size() const;
  void clear_weapons();
  static const int kWeaponsFieldNumber = 20;
  const ::MLWeaponState& weapons(int index) const;
  ::MLWeaponState* mutable_weapons(int index);
  ::MLWeaponState* add_weapons();
  ::google::protobuf::RepeatedPtrField< ::MLWeaponState >*
      mutable_weapons();
  const ::google::protobuf::RepeatedPtrField< ::MLWeaponState >&
      weapons() const;

  // optional string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string clan = 5;
  bool has_clan() const;
  void clear_clan();
  static const int kClanFieldNumber = 5;
  const ::std::string& clan() const;
  void set_clan(const ::std::string& value);
  #if LANG_CXX11
  void set_clan(::std::string&& value);
  #endif
  void set_clan(const char* value);
  void set_clan(const char* value, size_t size);
  ::std::string* mutable_clan();
  ::std::string* release_clan();
  void set_allocated_clan(::std::string* clan);

  // optional .CMsgVector abspos = 7;
  bool has_abspos() const;
  void clear_abspos();
  static const int kAbsposFieldNumber = 7;
  const ::CMsgVector& abspos() const;
  ::CMsgVector* release_abspos();
  ::CMsgVector* mutable_abspos();
  void set_allocated_abspos(::CMsgVector* abspos);

  // optional .CMsgQAngle eyeangle = 8;
  bool has_eyeangle() const;
  void clear_eyeangle();
  static const int kEyeangleFieldNumber = 8;
  const ::CMsgQAngle& eyeangle() const;
  ::CMsgQAngle* release_eyeangle();
  ::CMsgQAngle* mutable_eyeangle();
  void set_allocated_eyeangle(::CMsgQAngle* eyeangle);

  // optional .CMsgVector eyeangle_fwd = 9;
  bool has_eyeangle_fwd() const;
  void clear_eyeangle_fwd();
  static const int kEyeangleFwdFieldNumber = 9;
  const ::CMsgVector& eyeangle_fwd() const;
  ::CMsgVector* release_eyeangle_fwd();
  ::CMsgVector* mutable_eyeangle_fwd();
  void set_allocated_eyeangle_fwd(::CMsgVector* eyeangle_fwd);

  // optional int32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::int32 account_id() const;
  void set_account_id(::google::protobuf::int32 value);

  // optional int32 user_id = 2;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 user_id() const;
  void set_user_id(::google::protobuf::int32 value);

  // optional int32 entindex = 3;
  bool has_entindex() const;
  void clear_entindex();
  static const int kEntindexFieldNumber = 3;
  ::google::protobuf::int32 entindex() const;
  void set_entindex(::google::protobuf::int32 value);

  // optional .ETeam team = 6 [default = ET_Unknown];
  bool has_team() const;
  void clear_team();
  static const int kTeamFieldNumber = 6;
  ::ETeam team() const;
  void set_team(::ETeam value);

  // optional int32 health = 10;
  bool has_health() const;
  void clear_health();
  static const int kHealthFieldNumber = 10;
  ::google::protobuf::int32 health() const;
  void set_health(::google::protobuf::int32 value);

  // optional int32 armor = 11;
  bool has_armor() const;
  void clear_armor();
  static const int kArmorFieldNumber = 11;
  ::google::protobuf::int32 armor() const;
  void set_armor(::google::protobuf::int32 value);

  // optional float flashed = 12;
  bool has_flashed() const;
  void clear_flashed();
  static const int kFlashedFieldNumber = 12;
  float flashed() const;
  void set_flashed(float value);

  // optional float smoked = 13;
  bool has_smoked() const;
  void clear_smoked();
  static const int kSmokedFieldNumber = 13;
  float smoked() const;
  void set_smoked(float value);

  // optional int32 money = 14;
  bool has_money() const;
  void clear_money();
  static const int kMoneyFieldNumber = 14;
  ::google::protobuf::int32 money() const;
  void set_money(::google::protobuf::int32 value);

  // optional int32 round_kills = 15;
  bool has_round_kills() const;
  void clear_round_kills();
  static const int kRoundKillsFieldNumber = 15;
  ::google::protobuf::int32 round_kills() const;
  void set_round_kills(::google::protobuf::int32 value);

  // optional int32 round_killhs = 16;
  bool has_round_killhs() const;
  void clear_round_killhs();
  static const int kRoundKillhsFieldNumber = 16;
  ::google::protobuf::int32 round_killhs() const;
  void set_round_killhs(::google::protobuf::int32 value);

  // optional float burning = 17;
  bool has_burning() const;
  void clear_burning();
  static const int kBurningFieldNumber = 17;
  float burning() const;
  void set_burning(float value);

  // optional bool helmet = 18;
  bool has_helmet() const;
  void clear_helmet();
  static const int kHelmetFieldNumber = 18;
  bool helmet() const;
  void set_helmet(bool value);

  // optional bool defuse_kit = 19;
  bool has_defuse_kit() const;
  void clear_defuse_kit();
  static const int kDefuseKitFieldNumber = 19;
  bool defuse_kit() const;
  void set_defuse_kit(bool value);

  // @@protoc_insertion_point(class_scope:MLPlayerState)
 private:
  void set_has_account_id();
  void clear_has_account_id();
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_entindex();
  void clear_has_entindex();
  void set_has_name();
  void clear_has_name();
  void set_has_clan();
  void clear_has_clan();
  void set_has_team();
  void clear_has_team();
  void set_has_abspos();
  void clear_has_abspos();
  void set_has_eyeangle();
  void clear_has_eyeangle();
  void set_has_eyeangle_fwd();
  void clear_has_eyeangle_fwd();
  void set_has_health();
  void clear_has_health();
  void set_has_armor();
  void clear_has_armor();
  void set_has_flashed();
  void clear_has_flashed();
  void set_has_smoked();
  void clear_has_smoked();
  void set_has_money();
  void clear_has_money();
  void set_has_round_kills();
  void clear_has_round_kills();
  void set_has_round_killhs();
  void clear_has_round_killhs();
  void set_has_burning();
  void clear_has_burning();
  void set_has_helmet();
  void clear_has_helmet();
  void set_has_defuse_kit();
  void clear_has_defuse_kit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MLWeaponState > weapons_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr clan_;
  ::CMsgVector* abspos_;
  ::CMsgQAngle* eyeangle_;
  ::CMsgVector* eyeangle_fwd_;
  ::google::protobuf::int32 account_id_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 entindex_;
  int team_;
  ::google::protobuf::int32 health_;
  ::google::protobuf::int32 armor_;
  float flashed_;
  float smoked_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 round_kills_;
  ::google::protobuf::int32 round_killhs_;
  float burning_;
  bool helmet_;
  bool defuse_kit_;
  friend struct ::protobuf_fatdemo_2eproto::TableStruct;
  friend void ::protobuf_fatdemo_2eproto::InitDefaultsMLPlayerStateImpl();
};
// -------------------------------------------------------------------

class MLGameState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLGameState) */ {
 public:
  MLGameState();
  virtual ~MLGameState();

  MLGameState(const MLGameState& from);

  inline MLGameState& operator=(const MLGameState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MLGameState(MLGameState&& from) noexcept
    : MLGameState() {
    *this = ::std::move(from);
  }

  inline MLGameState& operator=(MLGameState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLGameState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLGameState* internal_default_instance() {
    return reinterpret_cast<const MLGameState*>(
               &_MLGameState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(MLGameState* other);
  friend void swap(MLGameState& a, MLGameState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MLGameState* New() const PROTOBUF_FINAL { return New(NULL); }

  MLGameState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MLGameState& from);
  void MergeFrom(const MLGameState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MLGameState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MLPlayerState players = 3;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 3;
  const ::MLPlayerState& players(int index) const;
  ::MLPlayerState* mutable_players(int index);
  ::MLPlayerState* add_players();
  ::google::protobuf::RepeatedPtrField< ::MLPlayerState >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::MLPlayerState >&
      players() const;

  // optional .MLMatchState match = 1;
  bool has_match() const;
  void clear_match();
  static const int kMatchFieldNumber = 1;
  const ::MLMatchState& match() const;
  ::MLMatchState* release_match();
  ::MLMatchState* mutable_match();
  void set_allocated_match(::MLMatchState* match);

  // optional .MLRoundState round = 2;
  bool has_round() const;
  void clear_round();
  static const int kRoundFieldNumber = 2;
  const ::MLRoundState& round() const;
  ::MLRoundState* release_round();
  ::MLRoundState* mutable_round();
  void set_allocated_round(::MLRoundState* round);

  // @@protoc_insertion_point(class_scope:MLGameState)
 private:
  void set_has_match();
  void clear_has_match();
  void set_has_round();
  void clear_has_round();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MLPlayerState > players_;
  ::MLMatchState* match_;
  ::MLRoundState* round_;
  friend struct ::protobuf_fatdemo_2eproto::TableStruct;
  friend void ::protobuf_fatdemo_2eproto::InitDefaultsMLGameStateImpl();
};
// -------------------------------------------------------------------

class MLDemoHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLDemoHeader) */ {
 public:
  MLDemoHeader();
  virtual ~MLDemoHeader();

  MLDemoHeader(const MLDemoHeader& from);

  inline MLDemoHeader& operator=(const MLDemoHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MLDemoHeader(MLDemoHeader&& from) noexcept
    : MLDemoHeader() {
    *this = ::std::move(from);
  }

  inline MLDemoHeader& operator=(MLDemoHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLDemoHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLDemoHeader* internal_default_instance() {
    return reinterpret_cast<const MLDemoHeader*>(
               &_MLDemoHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MLDemoHeader* other);
  friend void swap(MLDemoHeader& a, MLDemoHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MLDemoHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  MLDemoHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MLDemoHeader& from);
  void MergeFrom(const MLDemoHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MLDemoHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string map_name = 1;
  bool has_map_name() const;
  void clear_map_name();
  static const int kMapNameFieldNumber = 1;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_map_name(::std::string&& value);
  #endif
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // optional int32 tick_rate = 2;
  bool has_tick_rate() const;
  void clear_tick_rate();
  static const int kTickRateFieldNumber = 2;
  ::google::protobuf::int32 tick_rate() const;
  void set_tick_rate(::google::protobuf::int32 value);

  // optional uint32 version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional uint32 steam_universe = 4;
  bool has_steam_universe() const;
  void clear_steam_universe();
  static const int kSteamUniverseFieldNumber = 4;
  ::google::protobuf::uint32 steam_universe() const;
  void set_steam_universe(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MLDemoHeader)
 private:
  void set_has_map_name();
  void clear_has_map_name();
  void set_has_tick_rate();
  void clear_has_tick_rate();
  void set_has_version();
  void clear_has_version();
  void set_has_steam_universe();
  void clear_has_steam_universe();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  ::google::protobuf::int32 tick_rate_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 steam_universe_;
  friend struct ::protobuf_fatdemo_2eproto::TableStruct;
  friend void ::protobuf_fatdemo_2eproto::InitDefaultsMLDemoHeaderImpl();
};
// -------------------------------------------------------------------

class MLTick : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLTick) */ {
 public:
  MLTick();
  virtual ~MLTick();

  MLTick(const MLTick& from);

  inline MLTick& operator=(const MLTick& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MLTick(MLTick&& from) noexcept
    : MLTick() {
    *this = ::std::move(from);
  }

  inline MLTick& operator=(MLTick&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MLTick& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLTick* internal_default_instance() {
    return reinterpret_cast<const MLTick*>(
               &_MLTick_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(MLTick* other);
  friend void swap(MLTick& a, MLTick& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MLTick* New() const PROTOBUF_FINAL { return New(NULL); }

  MLTick* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MLTick& from);
  void MergeFrom(const MLTick& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MLTick* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MLEvent events = 3;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 3;
  const ::MLEvent& events(int index) const;
  ::MLEvent* mutable_events(int index);
  ::MLEvent* add_events();
  ::google::protobuf::RepeatedPtrField< ::MLEvent >*
      mutable_events();
  const ::google::protobuf::RepeatedPtrField< ::MLEvent >&
      events() const;

  // optional .MLGameState state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  const ::MLGameState& state() const;
  ::MLGameState* release_state();
  ::MLGameState* mutable_state();
  void set_allocated_state(::MLGameState* state);

  // optional int32 tick_count = 1;
  bool has_tick_count() const;
  void clear_tick_count();
  static const int kTickCountFieldNumber = 1;
  ::google::protobuf::int32 tick_count() const;
  void set_tick_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MLTick)
 private:
  void set_has_tick_count();
  void clear_has_tick_count();
  void set_has_state();
  void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MLEvent > events_;
  ::MLGameState* state_;
  ::google::protobuf::int32 tick_count_;
  friend struct ::protobuf_fatdemo_2eproto::TableStruct;
  friend void ::protobuf_fatdemo_2eproto::InitDefaultsMLTickImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MLDict

// optional string key = 1;
inline bool MLDict::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLDict::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLDict::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLDict::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& MLDict::key() const {
  // @@protoc_insertion_point(field_get:MLDict.key)
  return key_.GetNoArena();
}
inline void MLDict::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLDict.key)
}
#if LANG_CXX11
inline void MLDict::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLDict.key)
}
#endif
inline void MLDict::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLDict.key)
}
inline void MLDict::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLDict.key)
}
inline ::std::string* MLDict::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:MLDict.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLDict::release_key() {
  // @@protoc_insertion_point(field_release:MLDict.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLDict::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:MLDict.key)
}

// optional string val_string = 2;
inline bool MLDict::has_val_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLDict::set_has_val_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLDict::clear_has_val_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLDict::clear_val_string() {
  val_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_val_string();
}
inline const ::std::string& MLDict::val_string() const {
  // @@protoc_insertion_point(field_get:MLDict.val_string)
  return val_string_.GetNoArena();
}
inline void MLDict::set_val_string(const ::std::string& value) {
  set_has_val_string();
  val_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLDict.val_string)
}
#if LANG_CXX11
inline void MLDict::set_val_string(::std::string&& value) {
  set_has_val_string();
  val_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLDict.val_string)
}
#endif
inline void MLDict::set_val_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_val_string();
  val_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLDict.val_string)
}
inline void MLDict::set_val_string(const char* value, size_t size) {
  set_has_val_string();
  val_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLDict.val_string)
}
inline ::std::string* MLDict::mutable_val_string() {
  set_has_val_string();
  // @@protoc_insertion_point(field_mutable:MLDict.val_string)
  return val_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLDict::release_val_string() {
  // @@protoc_insertion_point(field_release:MLDict.val_string)
  clear_has_val_string();
  return val_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLDict::set_allocated_val_string(::std::string* val_string) {
  if (val_string != NULL) {
    set_has_val_string();
  } else {
    clear_has_val_string();
  }
  val_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), val_string);
  // @@protoc_insertion_point(field_set_allocated:MLDict.val_string)
}

// optional int32 val_int = 3;
inline bool MLDict::has_val_int() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLDict::set_has_val_int() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLDict::clear_has_val_int() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLDict::clear_val_int() {
  val_int_ = 0;
  clear_has_val_int();
}
inline ::google::protobuf::int32 MLDict::val_int() const {
  // @@protoc_insertion_point(field_get:MLDict.val_int)
  return val_int_;
}
inline void MLDict::set_val_int(::google::protobuf::int32 value) {
  set_has_val_int();
  val_int_ = value;
  // @@protoc_insertion_point(field_set:MLDict.val_int)
}

// optional float val_float = 4;
inline bool MLDict::has_val_float() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MLDict::set_has_val_float() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MLDict::clear_has_val_float() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MLDict::clear_val_float() {
  val_float_ = 0;
  clear_has_val_float();
}
inline float MLDict::val_float() const {
  // @@protoc_insertion_point(field_get:MLDict.val_float)
  return val_float_;
}
inline void MLDict::set_val_float(float value) {
  set_has_val_float();
  val_float_ = value;
  // @@protoc_insertion_point(field_set:MLDict.val_float)
}

// -------------------------------------------------------------------

// MLEvent

// optional string event_name = 1;
inline bool MLEvent::has_event_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLEvent::set_has_event_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLEvent::clear_has_event_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLEvent::clear_event_name() {
  event_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_event_name();
}
inline const ::std::string& MLEvent::event_name() const {
  // @@protoc_insertion_point(field_get:MLEvent.event_name)
  return event_name_.GetNoArena();
}
inline void MLEvent::set_event_name(const ::std::string& value) {
  set_has_event_name();
  event_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLEvent.event_name)
}
#if LANG_CXX11
inline void MLEvent::set_event_name(::std::string&& value) {
  set_has_event_name();
  event_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLEvent.event_name)
}
#endif
inline void MLEvent::set_event_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_event_name();
  event_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLEvent.event_name)
}
inline void MLEvent::set_event_name(const char* value, size_t size) {
  set_has_event_name();
  event_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLEvent.event_name)
}
inline ::std::string* MLEvent::mutable_event_name() {
  set_has_event_name();
  // @@protoc_insertion_point(field_mutable:MLEvent.event_name)
  return event_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLEvent::release_event_name() {
  // @@protoc_insertion_point(field_release:MLEvent.event_name)
  clear_has_event_name();
  return event_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLEvent::set_allocated_event_name(::std::string* event_name) {
  if (event_name != NULL) {
    set_has_event_name();
  } else {
    clear_has_event_name();
  }
  event_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event_name);
  // @@protoc_insertion_point(field_set_allocated:MLEvent.event_name)
}

// repeated .MLDict data = 2;
inline int MLEvent::data_size() const {
  return data_.size();
}
inline void MLEvent::clear_data() {
  data_.Clear();
}
inline const ::MLDict& MLEvent::data(int index) const {
  // @@protoc_insertion_point(field_get:MLEvent.data)
  return data_.Get(index);
}
inline ::MLDict* MLEvent::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:MLEvent.data)
  return data_.Mutable(index);
}
inline ::MLDict* MLEvent::add_data() {
  // @@protoc_insertion_point(field_add:MLEvent.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MLDict >*
MLEvent::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:MLEvent.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MLDict >&
MLEvent::data() const {
  // @@protoc_insertion_point(field_list:MLEvent.data)
  return data_;
}

// -------------------------------------------------------------------

// MLMatchState

// optional string game_mode = 1;
inline bool MLMatchState::has_game_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLMatchState::set_has_game_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLMatchState::clear_has_game_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLMatchState::clear_game_mode() {
  game_mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_mode();
}
inline const ::std::string& MLMatchState::game_mode() const {
  // @@protoc_insertion_point(field_get:MLMatchState.game_mode)
  return game_mode_.GetNoArena();
}
inline void MLMatchState::set_game_mode(const ::std::string& value) {
  set_has_game_mode();
  game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLMatchState.game_mode)
}
#if LANG_CXX11
inline void MLMatchState::set_game_mode(::std::string&& value) {
  set_has_game_mode();
  game_mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLMatchState.game_mode)
}
#endif
inline void MLMatchState::set_game_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_game_mode();
  game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLMatchState.game_mode)
}
inline void MLMatchState::set_game_mode(const char* value, size_t size) {
  set_has_game_mode();
  game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLMatchState.game_mode)
}
inline ::std::string* MLMatchState::mutable_game_mode() {
  set_has_game_mode();
  // @@protoc_insertion_point(field_mutable:MLMatchState.game_mode)
  return game_mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLMatchState::release_game_mode() {
  // @@protoc_insertion_point(field_release:MLMatchState.game_mode)
  clear_has_game_mode();
  return game_mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLMatchState::set_allocated_game_mode(::std::string* game_mode) {
  if (game_mode != NULL) {
    set_has_game_mode();
  } else {
    clear_has_game_mode();
  }
  game_mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_mode);
  // @@protoc_insertion_point(field_set_allocated:MLMatchState.game_mode)
}

// optional string phase = 2;
inline bool MLMatchState::has_phase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLMatchState::set_has_phase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLMatchState::clear_has_phase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLMatchState::clear_phase() {
  phase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_phase();
}
inline const ::std::string& MLMatchState::phase() const {
  // @@protoc_insertion_point(field_get:MLMatchState.phase)
  return phase_.GetNoArena();
}
inline void MLMatchState::set_phase(const ::std::string& value) {
  set_has_phase();
  phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLMatchState.phase)
}
#if LANG_CXX11
inline void MLMatchState::set_phase(::std::string&& value) {
  set_has_phase();
  phase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLMatchState.phase)
}
#endif
inline void MLMatchState::set_phase(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_phase();
  phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLMatchState.phase)
}
inline void MLMatchState::set_phase(const char* value, size_t size) {
  set_has_phase();
  phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLMatchState.phase)
}
inline ::std::string* MLMatchState::mutable_phase() {
  set_has_phase();
  // @@protoc_insertion_point(field_mutable:MLMatchState.phase)
  return phase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLMatchState::release_phase() {
  // @@protoc_insertion_point(field_release:MLMatchState.phase)
  clear_has_phase();
  return phase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLMatchState::set_allocated_phase(::std::string* phase) {
  if (phase != NULL) {
    set_has_phase();
  } else {
    clear_has_phase();
  }
  phase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phase);
  // @@protoc_insertion_point(field_set_allocated:MLMatchState.phase)
}

// optional int32 round = 3;
inline bool MLMatchState::has_round() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLMatchState::set_has_round() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLMatchState::clear_has_round() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLMatchState::clear_round() {
  round_ = 0;
  clear_has_round();
}
inline ::google::protobuf::int32 MLMatchState::round() const {
  // @@protoc_insertion_point(field_get:MLMatchState.round)
  return round_;
}
inline void MLMatchState::set_round(::google::protobuf::int32 value) {
  set_has_round();
  round_ = value;
  // @@protoc_insertion_point(field_set:MLMatchState.round)
}

// optional int32 score_ct = 4;
inline bool MLMatchState::has_score_ct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MLMatchState::set_has_score_ct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MLMatchState::clear_has_score_ct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MLMatchState::clear_score_ct() {
  score_ct_ = 0;
  clear_has_score_ct();
}
inline ::google::protobuf::int32 MLMatchState::score_ct() const {
  // @@protoc_insertion_point(field_get:MLMatchState.score_ct)
  return score_ct_;
}
inline void MLMatchState::set_score_ct(::google::protobuf::int32 value) {
  set_has_score_ct();
  score_ct_ = value;
  // @@protoc_insertion_point(field_set:MLMatchState.score_ct)
}

// optional int32 score_t = 5;
inline bool MLMatchState::has_score_t() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MLMatchState::set_has_score_t() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MLMatchState::clear_has_score_t() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MLMatchState::clear_score_t() {
  score_t_ = 0;
  clear_has_score_t();
}
inline ::google::protobuf::int32 MLMatchState::score_t() const {
  // @@protoc_insertion_point(field_get:MLMatchState.score_t)
  return score_t_;
}
inline void MLMatchState::set_score_t(::google::protobuf::int32 value) {
  set_has_score_t();
  score_t_ = value;
  // @@protoc_insertion_point(field_set:MLMatchState.score_t)
}

// -------------------------------------------------------------------

// MLRoundState

// optional string phase = 1;
inline bool MLRoundState::has_phase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLRoundState::set_has_phase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLRoundState::clear_has_phase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLRoundState::clear_phase() {
  phase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_phase();
}
inline const ::std::string& MLRoundState::phase() const {
  // @@protoc_insertion_point(field_get:MLRoundState.phase)
  return phase_.GetNoArena();
}
inline void MLRoundState::set_phase(const ::std::string& value) {
  set_has_phase();
  phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLRoundState.phase)
}
#if LANG_CXX11
inline void MLRoundState::set_phase(::std::string&& value) {
  set_has_phase();
  phase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLRoundState.phase)
}
#endif
inline void MLRoundState::set_phase(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_phase();
  phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLRoundState.phase)
}
inline void MLRoundState::set_phase(const char* value, size_t size) {
  set_has_phase();
  phase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLRoundState.phase)
}
inline ::std::string* MLRoundState::mutable_phase() {
  set_has_phase();
  // @@protoc_insertion_point(field_mutable:MLRoundState.phase)
  return phase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLRoundState::release_phase() {
  // @@protoc_insertion_point(field_release:MLRoundState.phase)
  clear_has_phase();
  return phase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLRoundState::set_allocated_phase(::std::string* phase) {
  if (phase != NULL) {
    set_has_phase();
  } else {
    clear_has_phase();
  }
  phase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phase);
  // @@protoc_insertion_point(field_set_allocated:MLRoundState.phase)
}

// optional .ETeam win_team = 2 [default = ET_Unknown];
inline bool MLRoundState::has_win_team() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLRoundState::set_has_win_team() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLRoundState::clear_has_win_team() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLRoundState::clear_win_team() {
  win_team_ = 0;
  clear_has_win_team();
}
inline ::ETeam MLRoundState::win_team() const {
  // @@protoc_insertion_point(field_get:MLRoundState.win_team)
  return static_cast< ::ETeam >(win_team_);
}
inline void MLRoundState::set_win_team(::ETeam value) {
  assert(::ETeam_IsValid(value));
  set_has_win_team();
  win_team_ = value;
  // @@protoc_insertion_point(field_set:MLRoundState.win_team)
}

// optional string bomb_state = 3;
inline bool MLRoundState::has_bomb_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLRoundState::set_has_bomb_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLRoundState::clear_has_bomb_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLRoundState::clear_bomb_state() {
  bomb_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bomb_state();
}
inline const ::std::string& MLRoundState::bomb_state() const {
  // @@protoc_insertion_point(field_get:MLRoundState.bomb_state)
  return bomb_state_.GetNoArena();
}
inline void MLRoundState::set_bomb_state(const ::std::string& value) {
  set_has_bomb_state();
  bomb_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLRoundState.bomb_state)
}
#if LANG_CXX11
inline void MLRoundState::set_bomb_state(::std::string&& value) {
  set_has_bomb_state();
  bomb_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLRoundState.bomb_state)
}
#endif
inline void MLRoundState::set_bomb_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bomb_state();
  bomb_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLRoundState.bomb_state)
}
inline void MLRoundState::set_bomb_state(const char* value, size_t size) {
  set_has_bomb_state();
  bomb_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLRoundState.bomb_state)
}
inline ::std::string* MLRoundState::mutable_bomb_state() {
  set_has_bomb_state();
  // @@protoc_insertion_point(field_mutable:MLRoundState.bomb_state)
  return bomb_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLRoundState::release_bomb_state() {
  // @@protoc_insertion_point(field_release:MLRoundState.bomb_state)
  clear_has_bomb_state();
  return bomb_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLRoundState::set_allocated_bomb_state(::std::string* bomb_state) {
  if (bomb_state != NULL) {
    set_has_bomb_state();
  } else {
    clear_has_bomb_state();
  }
  bomb_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bomb_state);
  // @@protoc_insertion_point(field_set_allocated:MLRoundState.bomb_state)
}

// -------------------------------------------------------------------

// MLWeaponState

// optional int32 index = 1;
inline bool MLWeaponState::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLWeaponState::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLWeaponState::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLWeaponState::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 MLWeaponState::index() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.index)
  return index_;
}
inline void MLWeaponState::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:MLWeaponState.index)
}

// optional string name = 2;
inline bool MLWeaponState::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLWeaponState::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLWeaponState::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLWeaponState::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MLWeaponState::name() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.name)
  return name_.GetNoArena();
}
inline void MLWeaponState::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLWeaponState.name)
}
#if LANG_CXX11
inline void MLWeaponState::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLWeaponState.name)
}
#endif
inline void MLWeaponState::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLWeaponState.name)
}
inline void MLWeaponState::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLWeaponState.name)
}
inline ::std::string* MLWeaponState::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MLWeaponState.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLWeaponState::release_name() {
  // @@protoc_insertion_point(field_release:MLWeaponState.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLWeaponState::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MLWeaponState.name)
}

// optional .EWeaponType type = 3 [default = EWT_Knife];
inline bool MLWeaponState::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MLWeaponState::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MLWeaponState::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MLWeaponState::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::EWeaponType MLWeaponState::type() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.type)
  return static_cast< ::EWeaponType >(type_);
}
inline void MLWeaponState::set_type(::EWeaponType value) {
  assert(::EWeaponType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:MLWeaponState.type)
}

// optional int32 ammo_clip = 4;
inline bool MLWeaponState::has_ammo_clip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MLWeaponState::set_has_ammo_clip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MLWeaponState::clear_has_ammo_clip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MLWeaponState::clear_ammo_clip() {
  ammo_clip_ = 0;
  clear_has_ammo_clip();
}
inline ::google::protobuf::int32 MLWeaponState::ammo_clip() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_clip)
  return ammo_clip_;
}
inline void MLWeaponState::set_ammo_clip(::google::protobuf::int32 value) {
  set_has_ammo_clip();
  ammo_clip_ = value;
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_clip)
}

// optional int32 ammo_clip_max = 5;
inline bool MLWeaponState::has_ammo_clip_max() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MLWeaponState::set_has_ammo_clip_max() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MLWeaponState::clear_has_ammo_clip_max() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MLWeaponState::clear_ammo_clip_max() {
  ammo_clip_max_ = 0;
  clear_has_ammo_clip_max();
}
inline ::google::protobuf::int32 MLWeaponState::ammo_clip_max() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_clip_max)
  return ammo_clip_max_;
}
inline void MLWeaponState::set_ammo_clip_max(::google::protobuf::int32 value) {
  set_has_ammo_clip_max();
  ammo_clip_max_ = value;
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_clip_max)
}

// optional int32 ammo_reserve = 6;
inline bool MLWeaponState::has_ammo_reserve() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MLWeaponState::set_has_ammo_reserve() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MLWeaponState::clear_has_ammo_reserve() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MLWeaponState::clear_ammo_reserve() {
  ammo_reserve_ = 0;
  clear_has_ammo_reserve();
}
inline ::google::protobuf::int32 MLWeaponState::ammo_reserve() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_reserve)
  return ammo_reserve_;
}
inline void MLWeaponState::set_ammo_reserve(::google::protobuf::int32 value) {
  set_has_ammo_reserve();
  ammo_reserve_ = value;
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_reserve)
}

// optional string state = 7;
inline bool MLWeaponState::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLWeaponState::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLWeaponState::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLWeaponState::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_state();
}
inline const ::std::string& MLWeaponState::state() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.state)
  return state_.GetNoArena();
}
inline void MLWeaponState::set_state(const ::std::string& value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLWeaponState.state)
}
#if LANG_CXX11
inline void MLWeaponState::set_state(::std::string&& value) {
  set_has_state();
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLWeaponState.state)
}
#endif
inline void MLWeaponState::set_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLWeaponState.state)
}
inline void MLWeaponState::set_state(const char* value, size_t size) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLWeaponState.state)
}
inline ::std::string* MLWeaponState::mutable_state() {
  set_has_state();
  // @@protoc_insertion_point(field_mutable:MLWeaponState.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLWeaponState::release_state() {
  // @@protoc_insertion_point(field_release:MLWeaponState.state)
  clear_has_state();
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLWeaponState::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    set_has_state();
  } else {
    clear_has_state();
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:MLWeaponState.state)
}

// optional float recoil_index = 8;
inline bool MLWeaponState::has_recoil_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MLWeaponState::set_has_recoil_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MLWeaponState::clear_has_recoil_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MLWeaponState::clear_recoil_index() {
  recoil_index_ = 0;
  clear_has_recoil_index();
}
inline float MLWeaponState::recoil_index() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.recoil_index)
  return recoil_index_;
}
inline void MLWeaponState::set_recoil_index(float value) {
  set_has_recoil_index();
  recoil_index_ = value;
  // @@protoc_insertion_point(field_set:MLWeaponState.recoil_index)
}

// -------------------------------------------------------------------

// MLPlayerState

// optional int32 account_id = 1;
inline bool MLPlayerState::has_account_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MLPlayerState::set_has_account_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MLPlayerState::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MLPlayerState::clear_account_id() {
  account_id_ = 0;
  clear_has_account_id();
}
inline ::google::protobuf::int32 MLPlayerState::account_id() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.account_id)
  return account_id_;
}
inline void MLPlayerState::set_account_id(::google::protobuf::int32 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.account_id)
}

// optional int32 user_id = 2;
inline bool MLPlayerState::has_user_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MLPlayerState::set_has_user_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MLPlayerState::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MLPlayerState::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 MLPlayerState::user_id() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.user_id)
  return user_id_;
}
inline void MLPlayerState::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.user_id)
}

// optional int32 entindex = 3;
inline bool MLPlayerState::has_entindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MLPlayerState::set_has_entindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MLPlayerState::clear_has_entindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MLPlayerState::clear_entindex() {
  entindex_ = 0;
  clear_has_entindex();
}
inline ::google::protobuf::int32 MLPlayerState::entindex() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.entindex)
  return entindex_;
}
inline void MLPlayerState::set_entindex(::google::protobuf::int32 value) {
  set_has_entindex();
  entindex_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.entindex)
}

// optional string name = 4;
inline bool MLPlayerState::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLPlayerState::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLPlayerState::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLPlayerState::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MLPlayerState::name() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.name)
  return name_.GetNoArena();
}
inline void MLPlayerState::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLPlayerState.name)
}
#if LANG_CXX11
inline void MLPlayerState::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLPlayerState.name)
}
#endif
inline void MLPlayerState::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLPlayerState.name)
}
inline void MLPlayerState::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLPlayerState.name)
}
inline ::std::string* MLPlayerState::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLPlayerState::release_name() {
  // @@protoc_insertion_point(field_release:MLPlayerState.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLPlayerState::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.name)
}

// optional string clan = 5;
inline bool MLPlayerState::has_clan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLPlayerState::set_has_clan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLPlayerState::clear_has_clan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLPlayerState::clear_clan() {
  clan_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clan();
}
inline const ::std::string& MLPlayerState::clan() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.clan)
  return clan_.GetNoArena();
}
inline void MLPlayerState::set_clan(const ::std::string& value) {
  set_has_clan();
  clan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLPlayerState.clan)
}
#if LANG_CXX11
inline void MLPlayerState::set_clan(::std::string&& value) {
  set_has_clan();
  clan_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLPlayerState.clan)
}
#endif
inline void MLPlayerState::set_clan(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clan();
  clan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLPlayerState.clan)
}
inline void MLPlayerState::set_clan(const char* value, size_t size) {
  set_has_clan();
  clan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLPlayerState.clan)
}
inline ::std::string* MLPlayerState::mutable_clan() {
  set_has_clan();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.clan)
  return clan_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLPlayerState::release_clan() {
  // @@protoc_insertion_point(field_release:MLPlayerState.clan)
  clear_has_clan();
  return clan_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLPlayerState::set_allocated_clan(::std::string* clan) {
  if (clan != NULL) {
    set_has_clan();
  } else {
    clear_has_clan();
  }
  clan_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clan);
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.clan)
}

// optional .ETeam team = 6 [default = ET_Unknown];
inline bool MLPlayerState::has_team() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MLPlayerState::set_has_team() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MLPlayerState::clear_has_team() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MLPlayerState::clear_team() {
  team_ = 0;
  clear_has_team();
}
inline ::ETeam MLPlayerState::team() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.team)
  return static_cast< ::ETeam >(team_);
}
inline void MLPlayerState::set_team(::ETeam value) {
  assert(::ETeam_IsValid(value));
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.team)
}

// optional .CMsgVector abspos = 7;
inline bool MLPlayerState::has_abspos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLPlayerState::set_has_abspos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLPlayerState::clear_has_abspos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::CMsgVector& MLPlayerState::abspos() const {
  const ::CMsgVector* p = abspos_;
  // @@protoc_insertion_point(field_get:MLPlayerState.abspos)
  return p != NULL ? *p : *reinterpret_cast<const ::CMsgVector*>(
      &::_CMsgVector_default_instance_);
}
inline ::CMsgVector* MLPlayerState::release_abspos() {
  // @@protoc_insertion_point(field_release:MLPlayerState.abspos)
  clear_has_abspos();
  ::CMsgVector* temp = abspos_;
  abspos_ = NULL;
  return temp;
}
inline ::CMsgVector* MLPlayerState::mutable_abspos() {
  set_has_abspos();
  if (abspos_ == NULL) {
    abspos_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:MLPlayerState.abspos)
  return abspos_;
}
inline void MLPlayerState::set_allocated_abspos(::CMsgVector* abspos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(abspos_);
  }
  if (abspos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      abspos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, abspos, submessage_arena);
    }
    set_has_abspos();
  } else {
    clear_has_abspos();
  }
  abspos_ = abspos;
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.abspos)
}

// optional .CMsgQAngle eyeangle = 8;
inline bool MLPlayerState::has_eyeangle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MLPlayerState::set_has_eyeangle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MLPlayerState::clear_has_eyeangle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::CMsgQAngle& MLPlayerState::eyeangle() const {
  const ::CMsgQAngle* p = eyeangle_;
  // @@protoc_insertion_point(field_get:MLPlayerState.eyeangle)
  return p != NULL ? *p : *reinterpret_cast<const ::CMsgQAngle*>(
      &::_CMsgQAngle_default_instance_);
}
inline ::CMsgQAngle* MLPlayerState::release_eyeangle() {
  // @@protoc_insertion_point(field_release:MLPlayerState.eyeangle)
  clear_has_eyeangle();
  ::CMsgQAngle* temp = eyeangle_;
  eyeangle_ = NULL;
  return temp;
}
inline ::CMsgQAngle* MLPlayerState::mutable_eyeangle() {
  set_has_eyeangle();
  if (eyeangle_ == NULL) {
    eyeangle_ = new ::CMsgQAngle;
  }
  // @@protoc_insertion_point(field_mutable:MLPlayerState.eyeangle)
  return eyeangle_;
}
inline void MLPlayerState::set_allocated_eyeangle(::CMsgQAngle* eyeangle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eyeangle_);
  }
  if (eyeangle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eyeangle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eyeangle, submessage_arena);
    }
    set_has_eyeangle();
  } else {
    clear_has_eyeangle();
  }
  eyeangle_ = eyeangle;
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.eyeangle)
}

// optional .CMsgVector eyeangle_fwd = 9;
inline bool MLPlayerState::has_eyeangle_fwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MLPlayerState::set_has_eyeangle_fwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MLPlayerState::clear_has_eyeangle_fwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::CMsgVector& MLPlayerState::eyeangle_fwd() const {
  const ::CMsgVector* p = eyeangle_fwd_;
  // @@protoc_insertion_point(field_get:MLPlayerState.eyeangle_fwd)
  return p != NULL ? *p : *reinterpret_cast<const ::CMsgVector*>(
      &::_CMsgVector_default_instance_);
}
inline ::CMsgVector* MLPlayerState::release_eyeangle_fwd() {
  // @@protoc_insertion_point(field_release:MLPlayerState.eyeangle_fwd)
  clear_has_eyeangle_fwd();
  ::CMsgVector* temp = eyeangle_fwd_;
  eyeangle_fwd_ = NULL;
  return temp;
}
inline ::CMsgVector* MLPlayerState::mutable_eyeangle_fwd() {
  set_has_eyeangle_fwd();
  if (eyeangle_fwd_ == NULL) {
    eyeangle_fwd_ = new ::CMsgVector;
  }
  // @@protoc_insertion_point(field_mutable:MLPlayerState.eyeangle_fwd)
  return eyeangle_fwd_;
}
inline void MLPlayerState::set_allocated_eyeangle_fwd(::CMsgVector* eyeangle_fwd) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eyeangle_fwd_);
  }
  if (eyeangle_fwd) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eyeangle_fwd = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eyeangle_fwd, submessage_arena);
    }
    set_has_eyeangle_fwd();
  } else {
    clear_has_eyeangle_fwd();
  }
  eyeangle_fwd_ = eyeangle_fwd;
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.eyeangle_fwd)
}

// optional int32 health = 10;
inline bool MLPlayerState::has_health() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MLPlayerState::set_has_health() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MLPlayerState::clear_has_health() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MLPlayerState::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline ::google::protobuf::int32 MLPlayerState::health() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.health)
  return health_;
}
inline void MLPlayerState::set_health(::google::protobuf::int32 value) {
  set_has_health();
  health_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.health)
}

// optional int32 armor = 11;
inline bool MLPlayerState::has_armor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MLPlayerState::set_has_armor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MLPlayerState::clear_has_armor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MLPlayerState::clear_armor() {
  armor_ = 0;
  clear_has_armor();
}
inline ::google::protobuf::int32 MLPlayerState::armor() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.armor)
  return armor_;
}
inline void MLPlayerState::set_armor(::google::protobuf::int32 value) {
  set_has_armor();
  armor_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.armor)
}

// optional float flashed = 12;
inline bool MLPlayerState::has_flashed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MLPlayerState::set_has_flashed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MLPlayerState::clear_has_flashed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MLPlayerState::clear_flashed() {
  flashed_ = 0;
  clear_has_flashed();
}
inline float MLPlayerState::flashed() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.flashed)
  return flashed_;
}
inline void MLPlayerState::set_flashed(float value) {
  set_has_flashed();
  flashed_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.flashed)
}

// optional float smoked = 13;
inline bool MLPlayerState::has_smoked() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MLPlayerState::set_has_smoked() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MLPlayerState::clear_has_smoked() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MLPlayerState::clear_smoked() {
  smoked_ = 0;
  clear_has_smoked();
}
inline float MLPlayerState::smoked() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.smoked)
  return smoked_;
}
inline void MLPlayerState::set_smoked(float value) {
  set_has_smoked();
  smoked_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.smoked)
}

// optional int32 money = 14;
inline bool MLPlayerState::has_money() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MLPlayerState::set_has_money() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MLPlayerState::clear_has_money() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MLPlayerState::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 MLPlayerState::money() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.money)
  return money_;
}
inline void MLPlayerState::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.money)
}

// optional int32 round_kills = 15;
inline bool MLPlayerState::has_round_kills() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MLPlayerState::set_has_round_kills() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MLPlayerState::clear_has_round_kills() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MLPlayerState::clear_round_kills() {
  round_kills_ = 0;
  clear_has_round_kills();
}
inline ::google::protobuf::int32 MLPlayerState::round_kills() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.round_kills)
  return round_kills_;
}
inline void MLPlayerState::set_round_kills(::google::protobuf::int32 value) {
  set_has_round_kills();
  round_kills_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.round_kills)
}

// optional int32 round_killhs = 16;
inline bool MLPlayerState::has_round_killhs() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MLPlayerState::set_has_round_killhs() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MLPlayerState::clear_has_round_killhs() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MLPlayerState::clear_round_killhs() {
  round_killhs_ = 0;
  clear_has_round_killhs();
}
inline ::google::protobuf::int32 MLPlayerState::round_killhs() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.round_killhs)
  return round_killhs_;
}
inline void MLPlayerState::set_round_killhs(::google::protobuf::int32 value) {
  set_has_round_killhs();
  round_killhs_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.round_killhs)
}

// optional float burning = 17;
inline bool MLPlayerState::has_burning() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MLPlayerState::set_has_burning() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MLPlayerState::clear_has_burning() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MLPlayerState::clear_burning() {
  burning_ = 0;
  clear_has_burning();
}
inline float MLPlayerState::burning() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.burning)
  return burning_;
}
inline void MLPlayerState::set_burning(float value) {
  set_has_burning();
  burning_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.burning)
}

// optional bool helmet = 18;
inline bool MLPlayerState::has_helmet() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MLPlayerState::set_has_helmet() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MLPlayerState::clear_has_helmet() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MLPlayerState::clear_helmet() {
  helmet_ = false;
  clear_has_helmet();
}
inline bool MLPlayerState::helmet() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.helmet)
  return helmet_;
}
inline void MLPlayerState::set_helmet(bool value) {
  set_has_helmet();
  helmet_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.helmet)
}

// optional bool defuse_kit = 19;
inline bool MLPlayerState::has_defuse_kit() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MLPlayerState::set_has_defuse_kit() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MLPlayerState::clear_has_defuse_kit() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MLPlayerState::clear_defuse_kit() {
  defuse_kit_ = false;
  clear_has_defuse_kit();
}
inline bool MLPlayerState::defuse_kit() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.defuse_kit)
  return defuse_kit_;
}
inline void MLPlayerState::set_defuse_kit(bool value) {
  set_has_defuse_kit();
  defuse_kit_ = value;
  // @@protoc_insertion_point(field_set:MLPlayerState.defuse_kit)
}

// repeated .MLWeaponState weapons = 20;
inline int MLPlayerState::weapons_size() const {
  return weapons_.size();
}
inline void MLPlayerState::clear_weapons() {
  weapons_.Clear();
}
inline const ::MLWeaponState& MLPlayerState::weapons(int index) const {
  // @@protoc_insertion_point(field_get:MLPlayerState.weapons)
  return weapons_.Get(index);
}
inline ::MLWeaponState* MLPlayerState::mutable_weapons(int index) {
  // @@protoc_insertion_point(field_mutable:MLPlayerState.weapons)
  return weapons_.Mutable(index);
}
inline ::MLWeaponState* MLPlayerState::add_weapons() {
  // @@protoc_insertion_point(field_add:MLPlayerState.weapons)
  return weapons_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MLWeaponState >*
MLPlayerState::mutable_weapons() {
  // @@protoc_insertion_point(field_mutable_list:MLPlayerState.weapons)
  return &weapons_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MLWeaponState >&
MLPlayerState::weapons() const {
  // @@protoc_insertion_point(field_list:MLPlayerState.weapons)
  return weapons_;
}

// -------------------------------------------------------------------

// MLGameState

// optional .MLMatchState match = 1;
inline bool MLGameState::has_match() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLGameState::set_has_match() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLGameState::clear_has_match() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLGameState::clear_match() {
  if (match_ != NULL) match_->Clear();
  clear_has_match();
}
inline const ::MLMatchState& MLGameState::match() const {
  const ::MLMatchState* p = match_;
  // @@protoc_insertion_point(field_get:MLGameState.match)
  return p != NULL ? *p : *reinterpret_cast<const ::MLMatchState*>(
      &::_MLMatchState_default_instance_);
}
inline ::MLMatchState* MLGameState::release_match() {
  // @@protoc_insertion_point(field_release:MLGameState.match)
  clear_has_match();
  ::MLMatchState* temp = match_;
  match_ = NULL;
  return temp;
}
inline ::MLMatchState* MLGameState::mutable_match() {
  set_has_match();
  if (match_ == NULL) {
    match_ = new ::MLMatchState;
  }
  // @@protoc_insertion_point(field_mutable:MLGameState.match)
  return match_;
}
inline void MLGameState::set_allocated_match(::MLMatchState* match) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete match_;
  }
  if (match) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      match = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, match, submessage_arena);
    }
    set_has_match();
  } else {
    clear_has_match();
  }
  match_ = match;
  // @@protoc_insertion_point(field_set_allocated:MLGameState.match)
}

// optional .MLRoundState round = 2;
inline bool MLGameState::has_round() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLGameState::set_has_round() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLGameState::clear_has_round() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLGameState::clear_round() {
  if (round_ != NULL) round_->Clear();
  clear_has_round();
}
inline const ::MLRoundState& MLGameState::round() const {
  const ::MLRoundState* p = round_;
  // @@protoc_insertion_point(field_get:MLGameState.round)
  return p != NULL ? *p : *reinterpret_cast<const ::MLRoundState*>(
      &::_MLRoundState_default_instance_);
}
inline ::MLRoundState* MLGameState::release_round() {
  // @@protoc_insertion_point(field_release:MLGameState.round)
  clear_has_round();
  ::MLRoundState* temp = round_;
  round_ = NULL;
  return temp;
}
inline ::MLRoundState* MLGameState::mutable_round() {
  set_has_round();
  if (round_ == NULL) {
    round_ = new ::MLRoundState;
  }
  // @@protoc_insertion_point(field_mutable:MLGameState.round)
  return round_;
}
inline void MLGameState::set_allocated_round(::MLRoundState* round) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete round_;
  }
  if (round) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      round = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, round, submessage_arena);
    }
    set_has_round();
  } else {
    clear_has_round();
  }
  round_ = round;
  // @@protoc_insertion_point(field_set_allocated:MLGameState.round)
}

// repeated .MLPlayerState players = 3;
inline int MLGameState::players_size() const {
  return players_.size();
}
inline void MLGameState::clear_players() {
  players_.Clear();
}
inline const ::MLPlayerState& MLGameState::players(int index) const {
  // @@protoc_insertion_point(field_get:MLGameState.players)
  return players_.Get(index);
}
inline ::MLPlayerState* MLGameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:MLGameState.players)
  return players_.Mutable(index);
}
inline ::MLPlayerState* MLGameState::add_players() {
  // @@protoc_insertion_point(field_add:MLGameState.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MLPlayerState >*
MLGameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:MLGameState.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MLPlayerState >&
MLGameState::players() const {
  // @@protoc_insertion_point(field_list:MLGameState.players)
  return players_;
}

// -------------------------------------------------------------------

// MLDemoHeader

// optional string map_name = 1;
inline bool MLDemoHeader::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLDemoHeader::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLDemoHeader::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLDemoHeader::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
inline const ::std::string& MLDemoHeader::map_name() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.map_name)
  return map_name_.GetNoArena();
}
inline void MLDemoHeader::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MLDemoHeader.map_name)
}
#if LANG_CXX11
inline void MLDemoHeader::set_map_name(::std::string&& value) {
  set_has_map_name();
  map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MLDemoHeader.map_name)
}
#endif
inline void MLDemoHeader::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MLDemoHeader.map_name)
}
inline void MLDemoHeader::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MLDemoHeader.map_name)
}
inline ::std::string* MLDemoHeader::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:MLDemoHeader.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MLDemoHeader::release_map_name() {
  // @@protoc_insertion_point(field_release:MLDemoHeader.map_name)
  clear_has_map_name();
  return map_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MLDemoHeader::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:MLDemoHeader.map_name)
}

// optional int32 tick_rate = 2;
inline bool MLDemoHeader::has_tick_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLDemoHeader::set_has_tick_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLDemoHeader::clear_has_tick_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLDemoHeader::clear_tick_rate() {
  tick_rate_ = 0;
  clear_has_tick_rate();
}
inline ::google::protobuf::int32 MLDemoHeader::tick_rate() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.tick_rate)
  return tick_rate_;
}
inline void MLDemoHeader::set_tick_rate(::google::protobuf::int32 value) {
  set_has_tick_rate();
  tick_rate_ = value;
  // @@protoc_insertion_point(field_set:MLDemoHeader.tick_rate)
}

// optional uint32 version = 3;
inline bool MLDemoHeader::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MLDemoHeader::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MLDemoHeader::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MLDemoHeader::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 MLDemoHeader::version() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.version)
  return version_;
}
inline void MLDemoHeader::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:MLDemoHeader.version)
}

// optional uint32 steam_universe = 4;
inline bool MLDemoHeader::has_steam_universe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MLDemoHeader::set_has_steam_universe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MLDemoHeader::clear_has_steam_universe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MLDemoHeader::clear_steam_universe() {
  steam_universe_ = 0u;
  clear_has_steam_universe();
}
inline ::google::protobuf::uint32 MLDemoHeader::steam_universe() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.steam_universe)
  return steam_universe_;
}
inline void MLDemoHeader::set_steam_universe(::google::protobuf::uint32 value) {
  set_has_steam_universe();
  steam_universe_ = value;
  // @@protoc_insertion_point(field_set:MLDemoHeader.steam_universe)
}

// -------------------------------------------------------------------

// MLTick

// optional int32 tick_count = 1;
inline bool MLTick::has_tick_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MLTick::set_has_tick_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MLTick::clear_has_tick_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MLTick::clear_tick_count() {
  tick_count_ = 0;
  clear_has_tick_count();
}
inline ::google::protobuf::int32 MLTick::tick_count() const {
  // @@protoc_insertion_point(field_get:MLTick.tick_count)
  return tick_count_;
}
inline void MLTick::set_tick_count(::google::protobuf::int32 value) {
  set_has_tick_count();
  tick_count_ = value;
  // @@protoc_insertion_point(field_set:MLTick.tick_count)
}

// optional .MLGameState state = 2;
inline bool MLTick::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MLTick::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MLTick::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MLTick::clear_state() {
  if (state_ != NULL) state_->Clear();
  clear_has_state();
}
inline const ::MLGameState& MLTick::state() const {
  const ::MLGameState* p = state_;
  // @@protoc_insertion_point(field_get:MLTick.state)
  return p != NULL ? *p : *reinterpret_cast<const ::MLGameState*>(
      &::_MLGameState_default_instance_);
}
inline ::MLGameState* MLTick::release_state() {
  // @@protoc_insertion_point(field_release:MLTick.state)
  clear_has_state();
  ::MLGameState* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::MLGameState* MLTick::mutable_state() {
  set_has_state();
  if (state_ == NULL) {
    state_ = new ::MLGameState;
  }
  // @@protoc_insertion_point(field_mutable:MLTick.state)
  return state_;
}
inline void MLTick::set_allocated_state(::MLGameState* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    set_has_state();
  } else {
    clear_has_state();
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:MLTick.state)
}

// repeated .MLEvent events = 3;
inline int MLTick::events_size() const {
  return events_.size();
}
inline void MLTick::clear_events() {
  events_.Clear();
}
inline const ::MLEvent& MLTick::events(int index) const {
  // @@protoc_insertion_point(field_get:MLTick.events)
  return events_.Get(index);
}
inline ::MLEvent* MLTick::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:MLTick.events)
  return events_.Mutable(index);
}
inline ::MLEvent* MLTick::add_events() {
  // @@protoc_insertion_point(field_add:MLTick.events)
  return events_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MLEvent >*
MLTick::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:MLTick.events)
  return &events_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MLEvent >&
MLTick::events() const {
  // @@protoc_insertion_point(field_list:MLTick.events)
  return events_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::EHitGroup> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EHitGroup>() {
  return ::EHitGroup_descriptor();
}
template <> struct is_proto_enum< ::ETeam> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ETeam>() {
  return ::ETeam_descriptor();
}
template <> struct is_proto_enum< ::EWeaponType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EWeaponType>() {
  return ::EWeaponType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fatdemo_2eproto__INCLUDED
